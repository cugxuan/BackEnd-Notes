#include <bits/stdc++.h>

using namespace std;

class Solution {
public:
//从n的2进制形式的最右边开始判断是不是1
    /*
    * 该解法如果输入时负数会陷入死循环，
    * 因为负数右移时，在最高位补得是1
    * 二本题最终目的是求1的个数，那么会有无数个
    * 1了。
    */
//注：a&b的结果是所有位相与的结果
//--------无法解决负数----------
    int NumberOf1_NotUse(int n) {
        int ans = 0;
        while (n) {
            if ((n & 1) == 1)
                ans++;
            n = n >> 1;
        }
        return ans;
    }

//---------------正解--------------------------------
//思想：用1（1自身左移运算，其实后来就不是1了）和n的每位进行位与，来判断1的个数
    int NumberOf1_low(int n) {
        int ans = 0;
        int flag = 1;
        while (flag != 0) {
            if ((n & flag) != 0) {
                ans++;
            }
            flag = flag << 1;
        }
        return ans;
    }

//--------------------最优解----------------------------
//举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。
//减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.
//我们发现减1的结果是把最右边的一个1开始的所有位都取反了。
//这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。
//如1100&1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，
//会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。
    int NumberOf1(int n) {
        int ans = 0;
        while (n != 0) {
            ++ans;
            n = (n - 1) & n;
        }
        return ans;
    }
//n=n&(n-1)这个方法得到的数是把二进制下从右往左的第一个1变成0
};

int main() {
}