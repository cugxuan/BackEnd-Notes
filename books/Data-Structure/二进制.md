# 二进制

## 二进制的位操作

- 左移 乘 2
- 右移 除 2

在 java 中定义了**逻辑右移**和**算术右移**，逻辑右移用>>>表示，算术右移用>>表示

C++ 中根据类型是否 signed 编译器自动判断，unsigned 使用逻辑右移，signed 使用算术右移

逻辑右移：直接将所有位右移，左边补 0 即可

算术右移：保持符号位不变，除符号位之外的右移一位并补符号位 1。补的 1 仍然在符号位之后
注：左移的时候不需要考虑，因为负数使用补码的形式存储，不会影响

## 补码

正数的补码 = 原码

负数的补码 = {原码符号位不变} + {数值位按位取反后+1} or
= {原码符号位不变} + {数值位从右边数第一个 1 及其右边的 0 保持不变,左边安位取反}

以十进制整数 +97 和-97 为例：

- +97 原码 = 0110_0001b
- +97 补码 = 0110_0001b
- -97 原码 = 1110_0001b
- -97 补码 = 1001_1111b

## 题目

「单选题」计算 1 到 128 所有位上 1 的个数
https://www.nowcoder.com/questionTerminal/a26078a2d13548349ca54a518a94d790

用二进制表示十进制数 1 到 4，分别为 1、10、11、100，这些二进制数所有位上 1 的个数共有 5 个。那么，用二进制表示的十进制数 1 到 128，所有位上 1 的个数共有`________`个。

- A. 448
- B. 449
- C. 1024
- D. 1025

「编程题」二进制中有多少个 1 - 剑指 offer
https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8

[题解](#题解)

---

## 题解

「单选题」计算 1 到 128 所有位上 1 的个数

128 对应的二进制的有 8 位，从 1 到 128，每个位置的 0 和 1 是交替的，前 7 位 0 和 1 的出现次数是相等的（这个很好理解，举个简单的例子，对于 001 到 100 之间的数是 001 010 011 100 ，对于前两位来说，可以看到 0 和 1 的数量是相等的）。所以有 7\*128/2 = 448，注意还需要加上 128 对应的 8 位上的 1，所以一共是 449 个，选 B

「编程题」二进制中有多少个 1 - 剑指 offer

```C++
#include <bits/stdc++.h>

using namespace std;

class Solution {
public:
//从n的2进制形式的最右边开始判断是不是1
    /*
    * 该解法如果输入时负数会陷入死循环，
    * 因为负数右移时，在最高位补得是1
    * 二本题最终目的是求1的个数，那么会有无数个
    * 1了。
    */
//注：a&b的结果是所有位相与的结果
//--------无法解决负数----------
    int NumberOf1_NotUse(int n) {
        int ans = 0;
        while (n) {
            if ((n & 1) == 1)
                ans++;
            n = n >> 1;
        }
        return ans;
    }

//---------------正解--------------------------------
//思想：用1（1自身左移运算，其实后来就不是1了）和n的每位进行位与，来判断1的个数
    int NumberOf1_low(int n) {
        int ans = 0;
        int flag = 1;
        while (flag != 0) {
            if ((n & flag) != 0) {
                ans++;
            }
            flag = flag << 1;
        }
        return ans;
    }

//--------------------最优解----------------------------
//举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。
//减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.
//我们发现减1的结果是把最右边的一个1开始的所有位都取反了。
//这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。
//如1100&1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，
//会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。
    int NumberOf1(int n) {
        int ans = 0;
        while (n != 0) {
            ++ans;
            n = (n - 1) & n;
        }
        return ans;
    }
//n=n&(n-1)这个方法得到的数是把二进制下从右往左的第一个1变成0
};

int main() {
}
```
